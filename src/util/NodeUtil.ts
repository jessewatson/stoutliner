import * as nodes from "../types/nodes";

//interface nodeIdPath {[index: number]: Array<string>;}
// todo - create a cach here in NodeUtil
// put it into state, or not -- doesn't really matter
// just lazily generate keys when getAncestorPath is called, 
// then delete keys whenever insertChild is called.
// or you can try to generate keys whenever insertChild is called - but you will miss places.
// You should also lazily generate them inside getAncestorPath as a backup
// be prepared not to have a perfect cache.
// Or should we work on any changes to the data model first?
// Auto-linking same-named nodes on blur?
// But with disparate sets of children, of course




// Node utility static class
export default class NodeUtil 
{
  // *****************************************************************
  // ******* PUBLIC STATIC MEMBERS ***********************************
  // *****************************************************************

  public static projectNodeId:number = 0;
  public static mainRootNodeId:number = 1;

  // Return a node object or null if not found
  static getNodeForId( nodeModel:nodes.NodeModel, id:number ): nodes.Node
  {
    let util = new NodeUtil(nodeModel);
    return util._getNode(id)
  }

  // Return the number of nodes below me, including myself
  static countNodesInSubtree( nodeModel:nodes.NodeModel, id:number ): number
  {
    let util = new NodeUtil(nodeModel);
    return util._depthFirstNodesIds(id).length;
  }

  // Return my parent
  static getParent( nodeModel:nodes.NodeModel, id:number ): nodes.Node
  {
    let util = new NodeUtil(nodeModel);
    return util._getParent(id);
  }

  // return boolean
  static childrenAreEqual( node1:nodes.Node, node2:nodes.Node )
  {
    if( node1.childIds.length != node2.childIds.length )
    {
      return false;
    }

    for( let i=0; i<node1.childIds.length; i++ )
    {
      if( node1.childIds[i] != node2.childIds[i] )
        return false;
    }

    return true;
  }

  // Return the number of nodes
  static getNumNodes( nodeModel:nodes.NodeModel ): number
  { // subtract one to account for the invisible root
    return nodeModel.nodes.length-1;
  }

  // returns a string
  static getNodeTextForId( nodeModel:nodes.NodeModel, id:number): string
  {
    let util = new NodeUtil(nodeModel);
    return util._getNodeTextForId(id);
  }

  // returns entire nodeModel
  static deleteNode(nodeModel:nodes.NodeModel, id:number ): nodes.NodeModel
  {
    let util = new NodeUtil(nodeModel);
    util._deleteNode(id);
    return util.nodeModel;
  } 

  // returns entire nodeModel
  static indent(nodeModel:nodes.NodeModel, id:number ): nodes.NodeModel
  {
    let util = new NodeUtil(nodeModel);
    util._indent(id);
    return util.nodeModel;
  }

  // returns entire nodeModel
  static addNodeBelow(nodeModel:nodes.NodeModel, id:number, addedNodeId:nodes.ReturnNodeIdCallback ): nodes.NodeModel
  {
    let util = new NodeUtil(nodeModel);
    let newNodeId = util._addNodeBelow( id );
    addedNodeId(newNodeId);
    return util.nodeModel;
  }

  // returns entire nodeModel
  static addNodeAbove(nodeModel:nodes.NodeModel, id:number, addedNodeId:nodes.ReturnNodeIdCallback ): nodes.NodeModel
  {
    let util = new NodeUtil(nodeModel);
    let newNodeId = util._addNodeAbove( id );
    addedNodeId(newNodeId);
    return util.nodeModel;
  }

  // returns entire nodeModel
  static updateNode(nodeModel:nodes.NodeModel, id:number, text:string ): nodes.NodeModel
  {
    let util = new NodeUtil(nodeModel);
    util._updateNodeAtomic( id, {text: text} );
    return util.nodeModel;
  }

  // returns entire nodeModel
  static unindent(nodeModel:nodes.NodeModel, id:number ): nodes.NodeModel
  {
    let util = new NodeUtil(nodeModel);
    util._unindent(id);
    return util.nodeModel;
  }

  // returns entire nodeModel
  static toggleExpansion(nodeModel:nodes.NodeModel, id:number ): nodes.NodeModel
  {
    let util = new NodeUtil(nodeModel);
    util._toggleExpansion(id);
    return util.nodeModel;
  }

  // returns entire nodeModel
  static ensureNodeExpanded(nodeModel:nodes.NodeModel, id:number ): nodes.NodeModel
  {
    let util = new NodeUtil(nodeModel);
    util._ensureNodeExpanded(id);
    return util.nodeModel;
  }

  // returns entire nodeModel
  static getOrAddNodeForQuery( nodeModel:nodes.NodeModel, query:string, returnNodeId:nodes.ReturnNodeIdCallback ): nodes.NodeModel
  {
    let util = new NodeUtil(nodeModel);
    returnNodeId( util._getOrAddNodeForQuery( query ).id );
    return util.nodeModel;
  }

  // returns string that displays the node tree
  static updateAutoGenerated(nodeModel:nodes.NodeModel, id:number ): nodes.NodeModel
  {
    let util = new NodeUtil(nodeModel);
    console.log("calling updateAutoGenerated on",util._getNode(id));

    //if( util._getNode(id).showRelatedChildren ) ADD BACK IN LATER?
    util._addRelated(id,true);

    return util.nodeModel;
  }

  // *****************************************************************
  // ******* "PRIVATE" INSTANCE METHODS ******************************
  // *****************************************************************

  private nodes: Array<nodes.Node>;

  private constructor( nodeModel:nodes.NodeModel )
  {
    this.nodes = nodeModel.nodes || [];
  }

  private get nodeModel (): nodes.NodeModel
  {
    return {nodes:this.nodes};
  }

  private _addRelated(currentNodeId:number,isMaster:boolean)
  {
    this._addRelatedChildren(currentNodeId,currentNodeId,isMaster);

    // TODO: When we implement add related tree nodes, that should go here prolly
  }

  private _gatherRelatedChildren(currentNodeId:number,childrenToGather:Array<number>): void
  {
    let currentNode = this._getNode(currentNodeId);

    if( currentNode.relatedChildOf != null )
    {
      childrenToGather.push(currentNode.id);
      for( let childId of currentNode.childIds )
      {
        this._gatherRelatedChildren(childId,childrenToGather);
      }
    }
  }

  //rootNodeId and currentNodeId start out as the same node
  private _addRelatedChildren(rootNodeId:number, currentNodeId:number, isMaster:boolean): void
  {
    let currentNode = this._getNode(currentNodeId);
    let currentText = currentNode.text.trim().toUpperCase();
    let rootNodeText = this._getNode(rootNodeId).text.trim().toUpperCase();

    //if there is no text, there are no related children
    if( currentText == "" )
    {
      return;
    }

    // create a list of all of the current node's ancestors
    let ancestorConceptPath = this._getAncestorConceptPath( currentNodeId );

    let alreadyAddedChildren:{ [index: string]: nodes.Node; } = {};

    // If this is the master, we won't have deleted all the child nodes first,
    // so we have to do this to prevent adding dupes
    if( isMaster )
    {
      // for each of our existing children
      for( let currentNodeChild of this._getChildNodes(currentNodeId) )
      {
        //create a set of all of current node's children...
        alreadyAddedChildren[ currentNodeChild.text.trim().toUpperCase() ] = currentNodeChild;
      }
    }

    //For each node that exists anywhere in the current tree
    for( let eachNodeId of this._depthFirstNodesIds() )
    {
      let eachNode = this._getNode(eachNodeId);

      if( eachNode == null )
      {
        // nodes may have gotten deleted
        console.log("Found null node",eachNodeId);
        break;
      }
      // no point in looking at other children
      // at this level if the contexts are incompatible

      // of the same concept as currentNodeId (including this node itself)
      if( eachNode.id != currentNodeId &&
          eachNode.text.trim().toUpperCase() == currentText &&
          this._isCompatibleContext( ancestorConceptPath, this._getAncestorConceptPath( eachNode.id ) ) )
      {
        //console.log("for",currentNode.text,"is compatible with",eachNode.text);
        //console.log("  ",ancestorConceptPath," matched ",this._getAncestorConceptPath( eachNode.id ))

        // examine each of its children, 
        for( let i=0; i<eachNode.childIds.length; i++ )
        {
          let childId = eachNode.childIds[i];
          let childNode = this._getNode( childId );
          let childText = childNode.text.trim().toUpperCase();
          let alreadyAddedChild = alreadyAddedChildren[ childText ];

          // add a new cloned version of the child, if...
          if( !alreadyAddedChild && // it's not a dupe we've already placed at this level
              childText != rootNodeText && // it's not the beginning of a cycle
              !childNode.relatedChildOf && // it is "native" to this context (not a "related", auto-added node)
              !childNode.relatedTreeNodeOf &&
              childText != "" ) // it's not blank
          {
            let newChildNode = this._addNewParentlessNode({
              relatedChildOf: isMaster ? null : childId,
              text: childNode.text,
              expanded: true
            });

            let inserted = false;
            if( isMaster )
            {
              console.log("Looking for location for ",newChildNode.id,newChildNode.text," i=",i);
              // determine insertion position
              // go up and find previous node
              //find index of newly added child

              // search up the foreign child list, looking for the node before us
              outer:
              for( let j=i-1; j>=0; j-- )
              {
                let lookupNode = this._getNode( this._getNode(eachNodeId).childIds[j] );
                console.log("  Foreign node ",lookupNode.id,lookupNode.text," j=",j);
                
                // go down the local child list, looking for the corresponding node
                let localIndex = 0;
                for( let tempNodeId of currentNode.childIds )
                {
                  let tempNode = this._getNode( tempNodeId );
                  console.log("  Local node ",tempNode.id,tempNode.text);
                  if( tempNode.text == lookupNode.text )
                  {
                    // then insert newChildNode right after "i" into currentNode
                    inserted = true;
                    // record that we've added this node
                    alreadyAddedChildren[ childText ] = newChildNode;
                    // re-lookup the current node, whose underlying pointer 
                    // may have changed due to the stupid react model
                    currentNode = this._getNode(currentNodeId);

                    console.log("  Adding at currentNode["+(localIndex+1)+"] ",currentNode);
                    //if( i+1 > currentNode.childIds.length )
                      //throw new Error("i="+(i+1)+" length="+currentNode.childIds.length);

                    this._insertChild( currentNode, newChildNode.id, localIndex+1 );
                    break outer;
                  }
                  localIndex++;
                }
              }
            }

            if( !inserted )
            {
              alreadyAddedChildren[ childText ] = newChildNode;
              // re-lookup the current node, whose underlying pointer 
              // may have changed due to the stupid react model
              currentNode = this._getNode(currentNodeId);

              this._insertChild( currentNode, newChildNode.id);
            }              
          }
        }
      }
    }

    // Now that my children have all been updated, recurse for each of them
    // re-lookup the current node, whose underlying pointer may have changed due to the stupid react model
    for( let childId of this._getNode(currentNodeId).childIds )
    {
      // recurse...
      this._addRelatedChildren( rootNodeId, childId, isMaster );
    }

  }

  // Walk up thisNodeId's ancestor path to the root. If we encounter each concept in "ancestorConceptPath"
  // SOMEWHERE in the (order independent), then return true that the two contexts are compatible.
  // If not EVERY concept in "ancestorConceptPath" is not represented somewhere in thisNodeId's ancestor
  // path, then return false that the two contexts are not compatible.
  private _isCompatibleContext( path1:Array<string>, path2:Array<string> ): boolean
  {
    let length = Math.min( path1.length, path2.length )

    for(let i=0; i<length; i++)
    {
        if( path1[i] != path2[i] )
        {
          return false
        }
    }

    return true;
  }

  // returns a list of depth-first node ids for the entire tree
  private _depthFirstNodesIds(id:number=0): Array<number>
  {
    let depthFirstList:Array<number> = [];
    this._buildDepthFirstNodeIds(id,depthFirstList);
    return depthFirstList;
  }

  private _buildDepthFirstNodeIds(nodeId:number,depthFirstList:Array<number>): void
  {
    depthFirstList.push(nodeId);
    let node = this._getNode(nodeId);
    
    for( let childId of node.childIds )
    {
      if( this._getNode(childId) == null )
      {
        console.log( "Passing NULL child id",childId,", parent id",node.id,", parent text ",node.text," working list",depthFirstList );
      }
      
      this._buildDepthFirstNodeIds(childId,depthFirstList);
    }
  }

  // should return its own concept id as the pathological case
  // note that this method is inclusive of the node passed into it!
  // (meaning that thisNodeId's conceptid will be present in the ancestor concept path returned)
  private _getAncestorConceptPath( thisNodeId:number ): Array<string>
  {
    let thisAncestor = this._getNode( thisNodeId );
    let ancestorConceptPath:Array<string> = [];

    while( thisAncestor != null &&
          thisAncestor.type != "mainroot" && 
          thisAncestor.type != "projectroot" ) // don't consider project root or main root
    {
      ancestorConceptPath.push( thisAncestor.text.trim().toUpperCase() );
      // move up the ancestor chain and repeat
      thisAncestor = this._getParent( thisAncestor.id );
    }
    // OUCH -- THIS IS SLOW!
    //this._updateNodeAtomic(thisNodeId, { ancestorPath: ancestorConceptPath } )

    return ancestorConceptPath;
  }
/*
  // If this node already has a conceptId, throws an error.
  // Otherwise, sees if there is already a concept with this text and associates the node with it.
  // Otherwise, sees if there are nodes with the same text, creates a concept with the text,
  // and associates all matching nodes with the concept.
  private _updateConcepts( id:number ): void
  {
    let updatedNode = this._getNode(id);

    let concept = this._getConceptByText( updatedNode.text );

    // If there is already a concept with this text
    if( concept != null )
    {
      this._associateNodeToConcept( updatedNode.id, concept.id );
    } 
    else if( updatedNode.conceptId == null ) // else if this node is not already associated with a concept
    {
      // see if there are any other nodes out there with the same text...
      for( let i=0; i<this.nodes.length; i++ )
      {
        const node = this.nodes[i];

        // if we're not comparing a node to itself, and their text matches
        if( node.id != updatedNode.id &&
            this._getNodeTextForId(node.id) == updatedNode.text )
        {
          // we found another node with the same text!

          // if this node is associated with a concept already...
          if( node.conceptId != null )
          {
            // grab the concept and adopt it as our own
            concept = this._getConcept( node.conceptId );
            this._associateNodeToConcept( updatedNode.id, node.conceptId );
          }
          else // otherwise, create a concept and associate them
          {
            concept = this._addOrGetConcept( updatedNode.text );
            // associate both nodes with the found concept
            this._associateNodeToConcept( updatedNode.id, concept.id );
            this._associateNodeToConcept( node.id, concept.id );
          }
        }
      }
    }
    else
    {
      throw new Error( "Attempt to update concepts for conceptless node id: " + updatedNode.id );
    }
  }

  private _associateNodeToConcept( nodeId:number, conceptId:number ): void
  {
    this._updateNodeAtomic( nodeId, { text:null, conceptId:conceptId } );
  }

  private _addOrGetConcept(text:string): nodes.Concept
  {
    const concept = this._getConceptByText(text);

    if( concept ) { return concept; }

    let newId = Math.floor(Math.random() * (99999 - 10000 + 1)) + 10000;
    let newConcept = {id: newId, text: text, type:"DEFAULT" };
    this.concepts = [ ...this.concepts, newConcept ];
    return newConcept;
  }
*/

  private _addNewParentlessNode( overrides?:nodes.NodeParams ): nodes.Node
  {
    let newId = Math.floor(Math.random() * (99999 - 10000 + 1)) + 10000;
    let newNode : nodes.Node = 
      { id: newId, 
        text: "", 
        showAsConcept: true,
        type: "standard",
        childIds: [], 
        expanded: true, 
        showRelatedChildren: true, 
        showRelatedTrees: true, 
        relatedChildOf: null, 
        relatedTreeNodeOf: null };

    if( overrides )
      Object.assign( newNode, overrides );

    this.nodes = [ ...this.nodes, newNode ];

    return newNode;
  }

  private _getNodeTextForId(id:number): string
  {
    const node = this._getNode(id);
    return node.text;
  }

  private _addNodeBelow( id:number ): number
  {
    // create new node
    let newNode = this._addNewParentlessNode();
    let currentNode = this._getNode(id);

    // If the current node has children and is expanded
    if( currentNode.childIds.length > 0 && currentNode.expanded )
    {
      // Insert the new node as a new "first child"
      this._insertChild( currentNode, newNode.id, 0 );
    }
    else
    {
      // Insert below the current node
      let parent = this._getParent(id);
      this._insertChild( parent, newNode.id, this._indexOfNodeId( id, parent.childIds )+1 );
    }

    return newNode.id;
  }

  private _addNodeAbove( id:number ): number
  {
    // create new node
    let newNode = this._addNewParentlessNode();
    let parentNode = this._getParent(id);

    let myIndex = parentNode.childIds.indexOf(id);

    // Insert below the current node
    this._insertChild( parentNode, newNode.id, myIndex );

    return newNode.id;
  }

  private _getNode( id:number ): nodes.Node
  {
    for( let node of this.nodes )
    {
      if( node.id == id )
        return node;
    }

    return null;
  }

  private _getOrAddNodeForQuery( query:string ): nodes.Node
  {
    const upperQuery = query.trim().toUpperCase();

    let autoRoot = null;

    for( let node of this.nodes )
    {
      if( node.type == "autoroot" && node.text.trim().toUpperCase() == upperQuery )
      {
        autoRoot = node;
        break;
      }
    }

    // **** START DEBUG TEMPORARY HACK!!!
    if( autoRoot )
    {
      this._deleteNode( autoRoot.id );
      autoRoot = null;
    }

    // re-add the auto root
    autoRoot = this._addNewParentlessNode({
      type: "autoroot",
      text: query.trim(),
      showAsConcept: false,
      showRelatedChildren: true
    });

    this._insertChild( this._getNode( NodeUtil.projectNodeId ), autoRoot.id );

    this._addRelated( autoRoot.id, false );

    // if no children were aded, add a blank child to give us a place to type
    if( this._getNode( autoRoot.id ).childIds.length == 0 )
    {
      let newChild = this._addNewParentlessNode();
      this._insertChild( autoRoot, newChild.id );
    }

    return autoRoot;
  }


  // attach newChildId to the supplied parent at position index
  // or add to the end if no index is supplied
  private _insertChild(parent:nodes.Node, newChildId:number, index:number=-1): void
  {
    let newChildIds = [];

    let i=0;
    for (let childId of parent.childIds) { 

      if (i === index) {
        newChildIds.push(newChildId);
      }

      newChildIds.push(childId);
      i++;
    }

    // if they did not supply an index param
    // or it is equal to the length (should be inserted at the end)
    if ((index < 0) || (index === newChildIds.length)) {
      newChildIds.push(newChildId);
    }

    this._updateNodeAtomic(parent.id, {childIds: newChildIds});
  }

  private _deleteNode(id:number): void
  {
    this._recursivelyDeleteChildren( this._getNode(id) );
    const parentNode = this._getParent( id );
    this._removeChild( parentNode, id );
    this._deleteFromNodesArray( id );
  }

  private _deleteFromNodesArray( id:number ): void
  {
    const index = this._indexOfNode( id, this.nodes );
    this.nodes = this.nodes.filter((_, i) => i !== index)
  }

  private _recursivelyDeleteChildren(parent:nodes.Node)
  {
    for (let childId of parent.childIds) 
    { 
      this._recursivelyDeleteChildren( this._getNode(childId) );
      this._deleteFromNodesArray( childId );
    }
  }

  private _removeChild(parent:nodes.Node, badChildId:number): void
  {
    let newChildIds = [];

    for (let childId of parent.childIds) { 
      if (childId !== badChildId) {
        newChildIds.push(childId);
      }
    }

    this._updateNodeAtomic(parent.id, {childIds: newChildIds});
  }

  private _getChildNodes(id: number): Array<nodes.Node>
  {
    let node = this._getNode(id);

    if (!node) { return null; }

    let childNodes = [];

    for (let childId of node.childIds) 
    {
      childNodes.push(this._getNode(childId));
    }

    return childNodes;
  }

  private _getParent(id:number): nodes.Node
  {
    for (let node of this.nodes) 
    {
      if (node.childIds.indexOf(id) >= 0) { return node; }
    }
    return null;
  }

  private _indent(id:number): boolean
  {
    let parent = this._getParent(id);
    let siblings = this._getChildNodes(parent.id);

    // my new parent should be the sibling right before me
    // find my index amongst my siblings
    let myIndex = this._indexOfNode(id, siblings);

    //if I'm the first child of my parent
    if (myIndex === 0) {
      console.log( "Refusing to indent" );
      return false; //bail out
    }

    // make the sibling right before me into my new parent...
    let newParent = siblings[myIndex-1];
    // remove myself from my current parent...
    this._removeChild(parent, id);
    // add myself as the indexth child of the new parent...
    this._insertChild(newParent, id);

    return true;
  }

  private _unindent(id:number): boolean
  {
    let parent = this._getParent(id);

    let grandparent = this._getParent(parent.id);

    if( grandparent == null ) {
      console.log( "Refusing to unindent" );
      return false;
    }

    // my new parent should be my parent's parent (grandparent)
    // my position should be just below what is currently my parent (but what will soon be my sibling)
    // find my parent's index amongst its siblings (its parent's children)
    let myIndex = (this._indexOfNodeId(parent.id, grandparent.childIds))+1;

    // make my grandparent into my new parent...
    // remove myself from my current parent...
    this._removeChild(parent, id);
    this._insertChild(grandparent, id, myIndex);

    return true;
  }

  private _toggleExpansion(id:number): void
  {
    const node = this._getNode(id);
    this._updateNodeAtomic( id, { expanded: !(node.expanded) } );
  }

  private _ensureNodeExpanded(id:number): void
  {
    const node = this._getNode(id);

    if( node == null )
    {
      console.log("WARNING: Attempting to ensure expansion of node id which does not exist: ",id);
      return;
    }

    if( !node.expanded )
    {
      this._updateNodeAtomic( id, { expanded: true } );
    }
    
    let parent = this._getParent( id );

    if( parent != null )
    {
      // call recursively up the chain
      this._ensureNodeExpanded(parent.id);
    }
  }

  private _indexOfNode(id:number, nodeList:Array<nodes.Node>): number
  {
    let i = 0;

    for (let node of nodeList) {
      if (node.id === id) {
        return i;
      }
      i++;
    }

    return -1;
  }

  private _indexOfNodeId(targetId:number, nodeIdList:Array<number>): number
  {
    let i = 0;

    for (let id of nodeIdList) {
      if (targetId === id) {
        return i;
      }
      i++;
    }

    return -1;
  }

  private _updateNodeAtomic(id:number, updates:any): void
  {
    this.nodes = this.nodes.map((node) => 
    {
      if( id == node.id ) 
      {
        return Object.assign({}, node, updates );;
      }
      return node;
    });
    
  }



}
