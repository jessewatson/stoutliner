import * as redux from "redux";
import NodeUtil from "../util/NodeUtil";


// nodes reducer
export default function nodeReducer( nodeModel={}, action ) {
  switch (action.type) {
    case 'NODES_GET_SAVE_UNDOABLE':
      return Object.assign(
        {},
        nodeModel,
        action.nodeModel
      );

    case 'NODES_STOREFOCUS_SAVE':
      return buildModel( action, nodeModel );

    case 'NODES_INDENT_SAVE_UNDOABLE':
      return buildModel( action,
        NodeUtil.indent( nodeModel, action.nodeId )
      );

    case 'NODES_UNINDENT_SAVE_UNDOABLE':
      return buildModel( action,
        NodeUtil.unindent( nodeModel, action.nodeId )
      );

    case 'NODES_ADDBELOW_SAVE_UNDOABLE':
      return buildModel( action,
        NodeUtil.addNodeBelow( nodeModel, action.nodeId, action.addedNode )
      );

    case 'NODES_ADDABOVE_SAVE_UNDOABLE':
      return buildModel( action,
        NodeUtil.addNodeAbove( nodeModel, action.nodeId, action.addedNode )
      );

    case 'NODES_DELETE_SAVE_UNDOABLE':
      return buildModel( action,
        NodeUtil.deleteNode( nodeModel, action.nodeId )
      );

    case 'NODES_UPDATE_SAVE_UNDOABLE':
      return buildModel( action,
        NodeUtil.updateNode( nodeModel, action.nodeId, action.text )
      );

    case 'NODES_TOGGLEEXPANSION_SAVE':
      return buildModel( action,
        NodeUtil.toggleExpansion( nodeModel, action.nodeId )
      );

    case 'NODES_GETORADDNODEFORQUERY_SAVE':
      return buildModel( action,
        NodeUtil.getOrAddNodeForQuery( nodeModel, action.query, action.returnNodeId )
      );

    case 'NODES_ENSUREEXPANDED_SAVE':
      let tempNodeModel = NodeUtil.ensureNodeExpanded( nodeModel, action.nodeId );
      return Object.assign(
        {},
        nodeModel,
        {
          nodes:tempNodeModel.nodes
        });

    case 'NODES_UPDATEAUTO_SAVE':
      return buildModel( action,
        NodeUtil.updateAutoGenerated( nodeModel, action.nodeId )
      );

    case 'NODES_PERSIST_SAVE': // no-op for the state, just saves the model
      return Object.assign( {}, nodeModel );

    // initial state
    default:
      return nodeModel;
  }
}

function buildModel( action, nodeModel )
{
  let newNodeModel = Object.assign( {}, nodeModel );

  // establish a minimal focus state container if not present
  if( !nodeModel.focusState )
  {
    newNodeModel.focusState = {};
  }
/* FOR DEBUGGING FOCUS ISSUES
  if( action.focusState == null )
  {
    console.log( "IN >> focusState OBJECT is NULL for action "+action.type );
  }
  else if( action.focusState.focusedNodeId == null )
  {
    console.log( "IN >> focusedNodeId is NULL for action "+action.type );
  }
  else
  {
    console.log( "IN >> focusedNodeId is "+action.focusState.focusedNodeId+" for action "+action.type );
  }
*/
  // only overwrite the focusState if not null
  if( action.focusState && action.focusState.focusedNodeId != null )
  {
    newNodeModel.focusState = Object.assign( {}, action.focusState );
  }

  // only overwrite the nodeTreeRevision if not null
  if( action.nodeTreeRevision != null )
  {
    newNodeModel.nodeTreeRevision = action.nodeTreeRevision;
  }
/*
  if( newNodeModel.focusState.focusedNodeId == null )
  {
    console.log( "OUT >> focusedNodeId is NULL for action "+action.type );
  }
  else
  {
    console.log( "OUT >> focusedNodeId is "+newNodeModel.focusState.focusedNodeId+" for action "+action.type );
  }
*/
  return newNodeModel;
}
